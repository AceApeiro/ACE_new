<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ACE – Zip Extractor (arXiv)</title>

  <!-- JSZip -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

  <!-- PDF.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>

  <style>
    :root{
      --bg:#0b0f14; --panel:#111827; --panel2:#0f172a; --muted:#94a3b8;
      --text:#e5e7eb; --good:#22c55e; --bad:#ef4444; --warn:#f59e0b; --line:#1f2937;
      --btn:#2563eb; --btn2:#334155;
    }
    *{box-sizing:border-box}
    body{margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial; background:var(--bg); color:var(--text)}
    .wrap{max-width:1400px; margin:0 auto; padding:14px}
    .top{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
    .card{background:linear-gradient(180deg,var(--panel),var(--panel2)); border:1px solid var(--line); border-radius:14px; padding:12px}
    .grow{flex:1}
    .row{display:flex; gap:12px; margin-top:12px}
    .colL{width:320px; min-width:280px}
    .colR{flex:1; min-width:320px}
    .h{display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:8px}
    .title{font-size:14px; font-weight:700}
    .muted{color:var(--muted); font-size:12px}
    .btn{border:0; background:var(--btn); color:white; padding:10px 12px; border-radius:10px; cursor:pointer; font-weight:700}
    .btn.secondary{background:var(--btn2)}
    .btn:disabled{opacity:.5; cursor:not-allowed}
    input[type="file"]{display:none}
    .fileLabel{display:inline-flex; gap:10px; align-items:center; border:1px dashed #334155; padding:10px 12px; border-radius:12px; cursor:pointer}
    .list{max-height:420px; overflow:auto; border-top:1px solid var(--line); margin-top:10px; padding-top:10px}
    .item{padding:10px; border:1px solid var(--line); border-radius:12px; margin-bottom:8px; cursor:pointer; background:#0b1220}
    .item.active{outline:2px solid #2563eb}
    .badge{font-size:11px; padding:3px 8px; border-radius:999px; border:1px solid var(--line); background:#0b1220}
    .badge.good{border-color:rgba(34,197,94,.6); color:var(--good)}
    .badge.bad{border-color:rgba(239,68,68,.6); color:var(--bad)}
    .badge.warn{border-color:rgba(245,158,11,.6); color:var(--warn)}
    .grid{display:grid; grid-template-columns: 1.35fr .65fr; gap:12px}
    .tabs{display:flex; gap:8px; flex-wrap:wrap}
    .tab{padding:8px 10px; border-radius:10px; border:1px solid var(--line); background:#0b1220; cursor:pointer; font-weight:700; font-size:12px}
    .tab.active{border-color:#2563eb}
    .pane{display:none}
    .pane.active{display:block}
    .box{border:1px solid var(--line); border-radius:12px; overflow:hidden; background:#050a12}
    .boxHead{padding:8px 10px; border-bottom:1px solid var(--line); display:flex; align-items:center; justify-content:space-between}
    .boxBody{padding:10px}
    textarea{width:100%; min-height:220px; background:#050a12; color:var(--text); border:1px solid var(--line); border-radius:12px; padding:10px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; font-size:12px}
    .kv{display:grid; grid-template-columns: 160px 1fr; gap:8px; font-size:13px}
    .k{color:var(--muted)}
    .statusLine{display:flex; gap:8px; flex-wrap:wrap; align-items:center}
    canvas{width:100%; height:auto; background:#0b1220; border-radius:10px}
    .htmlPreview{max-height:520px; overflow:auto; background:white; color:black; border-radius:10px; padding:10px}
    .small{font-size:12px}
    .hr{height:1px; background:var(--line); margin:10px 0}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace}
  </style>
</head>

<body>
<div class="wrap">

  <div class="top card">
    <div class="grow">
      <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap">
        <div>
          <div style="font-size:16px;font-weight:900;letter-spacing:.2px">ACE – Apeiro Citation Extractor (arXiv ZIP)</div>
          <div class="muted">Upload ZIP: PDF + API XML + Scraping XML + HTML summary (+ optional Final XML). Validates arXiv ID/version. Builds strict Elsevier ANI XML (authors+affiliations+orcid+refs).</div>
        </div>

        <div style="display:flex;gap:10px;align-items:center;flex-wrap:wrap">
          <label class="fileLabel">
            <span class="badge">ZIP</span>
            <span class="small">Choose ZIP</span>
            <input id="zipInput" type="file" accept=".zip" />
          </label>

          <button id="runBtn" class="btn" disabled>Run Extraction</button>
          <button id="downloadBtn" class="btn secondary" disabled>Download XML</button>
        </div>
      </div>

      <div class="hr"></div>

      <div class="statusLine">
        <span class="badge" id="zipBadge">No ZIP loaded</span>
        <span class="muted" id="hint">Tip: open DevTools Console if something doesn’t load.</span>
      </div>
    </div>
  </div>

  <div class="row">
    <!-- LEFT -->
    <div class="colL card">
      <div class="h">
        <div class="title">PDFs in ZIP</div>
        <div class="muted" id="fileCount">0</div>
      </div>

      <div class="muted">Select a PDF. ACE pairs support docs by reading their content.</div>
      <div class="list" id="fileList"></div>
    </div>

    <!-- RIGHT -->
    <div class="colR">
      <div class="grid">

        <!-- PREVIEW -->
        <div class="card">
          <div class="h">
            <div class="title">Preview</div>
            <div class="tabs">
              <div class="tab active" data-tab="pdfPane">PDF</div>
              <div class="tab" data-tab="htmlPane">HTML Summary</div>
              <div class="tab" data-tab="apiPane">API XML</div>
              <div class="tab" data-tab="scrapePane">Scrape XML</div>
              <div class="tab" data-tab="finalPane">Final XML (in ZIP)</div>
            </div>
          </div>

          <div id="pdfPane" class="pane active">
            <div class="box">
              <div class="boxHead">
                <div class="small muted">PDF rendered via PDF.js</div>
                <div style="display:flex;gap:8px;align-items:center">
                  <button class="btn secondary" id="prevPageBtn" disabled>Prev</button>
                  <span class="badge mono" id="pageInfo">- / -</span>
                  <button class="btn secondary" id="nextPageBtn" disabled>Next</button>
                </div>
              </div>
              <div class="boxBody">
                <canvas id="pdfCanvas"></canvas>
              </div>
            </div>
          </div>

          <div id="htmlPane" class="pane">
            <div class="box">
              <div class="boxHead">
                <div class="small muted">HTML is sanitized (scripts removed).</div>
              </div>
              <div class="boxBody">
                <div id="htmlPreview" class="htmlPreview">No HTML loaded.</div>
              </div>
            </div>
          </div>

          <div id="apiPane" class="pane">
            <textarea id="apiText" readonly placeholder="API XML preview..."></textarea>
          </div>

          <div id="scrapePane" class="pane">
            <textarea id="scrapeText" readonly placeholder="Scrape XML preview..."></textarea>
          </div>

          <div id="finalPane" class="pane">
            <textarea id="finalText" readonly placeholder="Final XML found in ZIP (if present)..."></textarea>
          </div>
        </div>

        <!-- EXTRACTION -->
        <div class="card">
          <div class="h">
            <div class="title">Extraction</div>
            <span class="badge" id="selectedSet">No set selected</span>
          </div>

          <div class="box">
            <div class="boxHead">
              <div class="small muted">Validation checks</div>
            </div>
            <div class="boxBody">
              <div class="kv">
                <div class="k">Detected arXiv ID</div><div class="mono" id="arxivIdVal">—</div>
                <div class="k">Detected version</div><div class="mono" id="versionVal">—</div>
                <div class="k">ID/Version match</div><div id="matchVal">—</div>
                <div class="k">Chosen title</div><div id="titleVal">—</div>
                <div class="k">Abstract found?</div><div id="absVal">—</div>
                <div class="k">Keywords found?</div><div id="kwVal">—</div>
                <div class="k">Authors/affils</div><div id="authVal">—</div>
                <div class="k">References</div><div id="refVal">—</div>
                <div class="k">ORCID</div><div id="orcidVal">—</div>
              </div>
            </div>
          </div>

          <div class="hr"></div>

          <div class="title" style="margin-bottom:8px">Generated XML (STRICT)</div>
          <textarea id="outXml" placeholder="Run Extraction to generate XML..." spellcheck="false"></textarea>
        </div>

      </div>
    </div>
  </div>
</div>

<script>
  // --- PDF.js worker ---
  pdfjsLib.GlobalWorkerOptions.workerSrc =
    "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";

  // ----------------------------
  // State
  // ----------------------------
  const state = {
    zip: null,
    fileNames: [],
    pdfs: [],
    selectedPdf: null,
    selected: { pdfName:null, apiName:null, scrapeName:null, htmlName:null, finalName:null },
    pdfDoc: null,
    pdfPageNum: 1,
    pdfPageCount: 0
  };

  // ----------------------------
  // UI refs
  // ----------------------------
  const zipInput = document.getElementById("zipInput");
  const runBtn = document.getElementById("runBtn");
  const downloadBtn = document.getElementById("downloadBtn");

  const zipBadge = document.getElementById("zipBadge");
  const fileCount = document.getElementById("fileCount");
  const fileList = document.getElementById("fileList");
  const selectedSet = document.getElementById("selectedSet");

  const apiText = document.getElementById("apiText");
  const scrapeText = document.getElementById("scrapeText");
  const htmlPreview = document.getElementById("htmlPreview");
  const finalText = document.getElementById("finalText");

  const arxivIdVal = document.getElementById("arxivIdVal");
  const versionVal = document.getElementById("versionVal");
  const matchVal = document.getElementById("matchVal");
  const titleVal = document.getElementById("titleVal");
  const absVal = document.getElementById("absVal");
  const kwVal = document.getElementById("kwVal");
  const authVal = document.getElementById("authVal");
  const refVal = document.getElementById("refVal");
  const orcidVal = document.getElementById("orcidVal");

  const outXml = document.getElementById("outXml");

  const pdfCanvas = document.getElementById("pdfCanvas");
  const prevPageBtn = document.getElementById("prevPageBtn");
  const nextPageBtn = document.getElementById("nextPageBtn");
  const pageInfo = document.getElementById("pageInfo");

  // Tabs
  document.querySelectorAll(".tab").forEach(t => {
    t.addEventListener("click", () => {
      document.querySelectorAll(".tab").forEach(x => x.classList.remove("active"));
      document.querySelectorAll(".pane").forEach(p => p.classList.remove("active"));
      t.classList.add("active");
      document.getElementById(t.dataset.tab).classList.add("active");
    });
  });

  // ----------------------------
  // Helpers
  // ----------------------------
  const lower = s => (s || "").toLowerCase();

  function escapeHtml(s) {
    return String(s ?? "").replace(/[&<>"']/g, c => ({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
    }[c]));
  }

  function badge(text, kind="") {
    const cls = kind ? `badge ${kind}` : "badge";
    return `<span class="${cls}">${escapeHtml(text)}</span>`;
  }

  function stripScripts(html) {
    const doc = new DOMParser().parseFromString(html, "text/html");
    doc.querySelectorAll("script, iframe, object, embed").forEach(n => n.remove());
    doc.querySelectorAll("*").forEach(el => {
      [...el.attributes].forEach(a => {
        if (a.name.startsWith("on")) el.removeAttribute(a.name);
      });
    });
    return doc.body.innerHTML || "";
  }

  // arXiv ID + version
  const ARXIV_ID_RE = /(\d{4}\.\d{4,5})(v\d+)?/i;

  function extractArxivFromText(text) {
    if (!text) return { id:null, version:null };
    const m1 = /arxiv:\s*(\d{4}\.\d{4,5})(v\d+)?/i.exec(text);
    if (m1) return { id: m1[1], version: (m1[2]||null) };
    const m2 = /oai:arxiv\.org:(\d{4}\.\d{4,5})/i.exec(text);
    if (m2) return { id: m2[1], version: null };
    const m3 = ARXIV_ID_RE.exec(text);
    if (m3) return { id: m3[1], version: (m3[2]||null) };
    return { id:null, version:null };
  }

  // Emails / ORCID
  const EMAIL_RE = /[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}/ig;
  const ORCID_RE = /\b(\d{4}-\d{4}-\d{4}-\d{3}[\dX])\b/g;

  function uniq(arr){ return [...new Set((arr||[]).filter(Boolean))]; }

  // --- XML helpers ---
  function xmlText(node, tagName) {
    const el = node.getElementsByTagName(tagName)[0];
    return el ? (el.textContent || "").trim() : "";
  }

  function parseApiXml(xmlStr) {
    const doc = new DOMParser().parseFromString(xmlStr, "text/xml");
    const id = xmlText(doc, "id");
    const title = xmlText(doc, "title");
    const abstract = xmlText(doc, "abstract");
    const authors = [...doc.getElementsByTagName("author")].map(a => ({
      keyname: xmlText(a, "keyname"),
      forenames: xmlText(a, "forenames")
    }));
    return { id, title, abstract, authors };
  }

  function parseScrapeXml(xmlStr) {
    const doc = new DOMParser().parseFromString(xmlStr, "text/xml");
    const item = doc.getElementsByTagName("item")[0];
    const id = item?.getAttribute("id") || "";
    const v = doc.getElementsByTagName("version")[0];
    let version = "";
    if (v) {
      const number = v.getAttribute("number") || ""; // like [v2]
      const m = /\[v(\d+)\]/i.exec(number);
      if (m) version = "v" + m[1];
    }
    return { id, version };
  }

  function parseHtmlLanding(htmlStr) {
    const doc = new DOMParser().parseFromString(htmlStr, "text/html");
    const bodyText = doc.body?.textContent || "";
    const { id, version } = extractArxivFromText(bodyText);

    // title
    let title = (doc.querySelector('meta[name="citation_title"]')?.getAttribute("content") || "").trim();
    if (!title) title = (doc.title || "").trim();

    // abstract - best-effort
    const fullText = bodyText.replace(/\s+/g," ").trim();
    let abstract = "";
    const absIdx = fullText.toLowerCase().indexOf("abstract");
    if (absIdx !== -1) {
      const slice = fullText.slice(absIdx);
      const stop = slice.search(/\b(comments|subjects|cite as|submission history|full-text links)\b/i);
      abstract = (stop > 0 ? slice.slice(0, stop) : slice).replace(/\babstract\b\s*:?\s*/i,"").trim();
    }

    // meta keywords (ONLY if explicitly present)
    const metaKw =
      (doc.querySelector('meta[name="citation_keywords"]')?.getAttribute("content") || "").trim();

    return {
      id, version, title, abstract,
      metaKw,
      sanitizedHtml: stripScripts(htmlStr),
      rawText: bodyText
    };
  }

  // ----------------------------
  // PDF text extraction (for real affils/refs/kw/orcid/email)
  // ----------------------------
  async function extractPdfPageLines(pageNum) {
    if (!state.pdfDoc) return [];
    const page = await state.pdfDoc.getPage(pageNum);
    const tc = await page.getTextContent();

    // group by Y coordinate (transform[5])
    const rows = new Map();
    for (const it of tc.items) {
      const str = (it.str || "").trim();
      if (!str) continue;
      const y = Math.round(it.transform[5]); // bucket
      const x = it.transform[4];
      const list = rows.get(y) || [];
      list.push({ x, str });
      rows.set(y, list);
    }

    // sort rows top->bottom (y desc), inside each row left->right (x asc)
    const ys = [...rows.keys()].sort((a,b)=>b-a);
    const lines = ys.map(y=>{
      const parts = rows.get(y).sort((a,b)=>a.x-b.x).map(p=>p.str);
      return parts.join(" ").replace(/\s+/g," ").trim();
    }).filter(Boolean);

    return lines;
  }

  async function extractPdfTextFirstPages(nPages=2) {
    const max = Math.min(nPages, state.pdfPageCount || 0);
    const all = [];
    for (let p=1; p<=max; p++){
      const lines = await extractPdfPageLines(p);
      all.push(lines.join("\n"));
    }
    return all.join("\n\n");
  }

  async function extractPdfTextAllPagesCap(maxPages=30) {
    const max = Math.min(maxPages, state.pdfPageCount || 0);
    const all = [];
    for (let p=1; p<=max; p++){
      const lines = await extractPdfPageLines(p);
      all.push(lines.join("\n"));
    }
    return all.join("\n\n");
  }

  function parseAffiliationsFromPdfFirstPage(pdfText) {
    // best-effort: take text between title/authors block and "Abstract"
    const t = (pdfText || "").replace(/\r/g,"");
    const idxAbs = t.toLowerCase().indexOf("\nabstract");
    const head = idxAbs !== -1 ? t.slice(0, idxAbs) : t.slice(0, 2500);

    const lines = head.split("\n").map(x=>x.trim()).filter(Boolean);

    // candidate lines often contain these tokens
    const hits = lines.filter(l =>
      /university|universit|institute|department|laborator|school|centre|center|observatorio|observatory|cnrs|infn|inaf|faculty|college/i.test(l)
      || /, [A-Z]{2,}\b/.test(l) // country/abbr
    );

    // collapse obvious duplicates / too short fragments
    const cleaned = [];
    for (const h of hits) {
      if (h.length < 8) continue;
      if (cleaned.some(x => x.includes(h) || h.includes(x))) continue;
      cleaned.push(h);
    }

    // if nothing found, return empty (better than fake)
    return cleaned.slice(0, 8);
  }

  function parseKeywordsStrict(pdfTextFirstPages, htmlObj) {
    // 1) explicit meta keywords only
    if (htmlObj?.metaKw) {
      return htmlObj.metaKw.split(/[;,|•\u2022]+/).map(s=>s.trim()).filter(Boolean);
    }

    // 2) ONLY if PDF contains a clear "Keywords:" line near Abstract
    const t = (pdfTextFirstPages || "");
    const absPos = t.toLowerCase().indexOf("abstract");
    const windowStart = absPos !== -1 ? Math.max(0, absPos - 800) : 0;
    const windowEnd = absPos !== -1 ? Math.min(t.length, absPos + 1400) : Math.min(t.length, 2000);
    const slice = t.slice(windowStart, windowEnd);

    const m = /\bkeywords?\b\s*[:\-]\s*([^\n]{3,250})/i.exec(slice);
    if (!m) return [];
    const raw = m[1].trim();

    // stop at typical section starts
    const stop = raw.split(/\b(abstract|introduction|contents|1\.)\b/i)[0].trim();
    return stop.split(/[;•,\u2022|·\u00b7\/]+/).map(s => s.trim()).filter(Boolean);
  }

  function parseReferencesFromPdf(pdfTextAll) {
    const t = (pdfTextAll || "").replace(/\r/g,"");
    const idx = t.toLowerCase().indexOf("\nreferences");
    if (idx === -1) return [];

    const tail = t.slice(idx + 11).trim();
    if (!tail) return [];

    // split on patterns like [1], [2] or "1." at start of line
    const lines = tail.split("\n").map(x=>x.trim()).filter(Boolean);

    const refs = [];
    let cur = "";

    function pushCur() {
      const s = cur.trim().replace(/\s+/g," ");
      if (s && s.length > 15) refs.push(s);
      cur = "";
    }

    for (const line of lines) {
      const isNew =
        /^\[\d+\]\s*/.test(line) ||
        /^\d+\.\s+/.test(line);

      if (isNew) {
        pushCur();
        cur = line.replace(/^\[\d+\]\s*/,"").replace(/^\d+\.\s+/,"");
      } else {
        // continue current reference
        cur += " " + line;
      }

      if (refs.length >= 300) break;
    }
    pushCur();

    // Deduplicate obvious repeats
    const uniqRefs = [];
    for (const r of refs) {
      if (uniqRefs.some(x => x === r)) continue;
      uniqRefs.push(r);
    }
    return uniqRefs;
  }

  // ----------------------------
  // STRICT Elsevier ANI XML builder (structure matches your sample)
  // ----------------------------
  function escapeXml(s){
    return String(s||"").replace(/[<>&'"]/g, c => ({'<':'&lt;','>':'&gt;','&':'&amp;',"'":'&apos;','"':'&quot;'}[c]));
  }

  function buildAuthorsXml(authorGroups) {
    // authorGroups: [{ seq, authors:[{forenames,keyname,email,orcid}], affiliation:{...} }]
    let out = "";
    for (const g of authorGroups) {
      out += `          <author-group seq="${g.seq}">\n`;
      for (const a of g.authors) {
        const given = a.forenames || "";
        const surname = a.keyname || "";
        const initials = given.split(/\s+/).filter(Boolean).map(x => x[0].toUpperCase() + ".").join("");

        out += `            <author seq="${escapeXml(a.seq)}">\n`;
        out += `              <ce:initials>${escapeXml(initials || "")}</ce:initials>\n`;
        out += `              <ce:surname>${escapeXml(surname)}</ce:surname>\n`;
        out += `              <ce:given-name>${escapeXml(given)}</ce:given-name>\n`;
        if (a.email) out += `              <ce:e-address>${escapeXml(a.email)}</ce:e-address>\n`;
        if (a.orcid) out += `              <ce:orcid>${escapeXml(a.orcid)}</ce:orcid>\n`;
        out += `            </author>\n`;
      }

      if (g.affiliation) {
        out += `            <affiliation>\n`;
        // Keep same “telemetry comment” slot as your sample (even if unknown)
        out += `              <!-- telemetry: {"confidence": ${escapeXml(g.affiliation.confidence ?? 0.5)} } -->\n`;
        for (const org of (g.affiliation.organizations || [])) {
          out += `              <organization>${escapeXml(org)}</organization>\n`;
        }
        if (g.affiliation.addressPart) out += `              <address-part>${escapeXml(g.affiliation.addressPart)}</address-part>\n`;
        if (g.affiliation.city) out += `              <city>${escapeXml(g.affiliation.city)}</city>\n`;
        if (g.affiliation.postalCode) out += `              <postal-code>${escapeXml(g.affiliation.postalCode)}</postal-code>\n`;
        if (g.affiliation.countryIso) out += `              <country iso-code="${escapeXml(g.affiliation.countryIso)}"/>\n`;
        if (g.affiliation.sourceText) out += `              <ce:source-text>${escapeXml(g.affiliation.sourceText)}</ce:source-text>\n`;
        out += `            </affiliation>\n`;
      }

      out += `          </author-group>\n`;
    }
    return out;
  }

  function buildKeywordsXml(keywords) {
    if (!keywords || !keywords.length) return "";
    return `            <author-keywords>\n${keywords.map(k => `              <author-keyword>${escapeXml(k)}</author-keyword>`).join("\n")}\n            </author-keywords>\n`;
  }

  function buildAbstractXml(abstractText) {
    if (!abstractText) return "";
    return `          <abstracts>\n` +
           `            <abstract original="y" xml:lang="ENG">\n` +
           `              <ce:para>${escapeXml(abstractText)}</ce:para>\n` +
           `            </abstract>\n` +
           `          </abstracts>\n`;
  }

  function buildBibliographyXml(refs) {
    const list = refs || [];
    let out = `        <tail>\n`;
    out += `          <bibliography refcount="${list.length}">\n`;
    for (let i=0;i<list.length;i++) {
      const seq = i+1;
      const r = list[i];
      out += `            <reference seq="${seq}">\n`;
      out += `              <ref-info/>\n`;
      out += `              <ref-fulltext>${escapeXml(r)}</ref-fulltext>\n`;
      out += `              <ce:source-text>${escapeXml(r)}</ce:source-text>\n`;
      out += `            </reference>\n`;
    }
    out += `          </bibliography>\n`;
    out += `        </tail>\n`;
    return out;
  }

  function buildElsevierXmlStrict({ arxivIdWithVersion, chosenTitle, abstractText, keywords, authorGroups, references }) {
    const nowIso = new Date().toISOString();

    const kwXml = buildKeywordsXml(keywords);
    const absXml = buildAbstractXml(abstractText);
    const authorsXml = buildAuthorsXml(authorGroups);
    const bibXml = buildBibliographyXml(references);

    return `<?xml version="1.0" encoding="utf-8"?>\n` +
`<units xmlns="http://www.elsevier.com/xml/ani/ani" xmlns:ce="http://www.elsevier.com/xml/ani/common">\n` +
`  <unit type="ARTICLE">\n` +
`    <unit-info>\n` +
`      <unit-id>1</unit-id>\n` +
`      <order-id>unknown</order-id>\n` +
`      <parcel-id>none</parcel-id>\n` +
`      <supplier-id>4</supplier-id>\n` +
`      <timestamp>${escapeXml(nowIso)}</timestamp>\n` +
`    </unit-info>\n` +
`    <unit-content>\n` +
`      <bibrecord>\n` +
`        <item-info>\n` +
`          <status state="new"/>\n` +
`          <itemidlist>\n` +
`            <itemid idtype="ARXIV">${escapeXml(arxivIdWithVersion)}</itemid>\n` +
`          </itemidlist>\n` +
`        </item-info>\n` +
`        <head>\n` +
`          <citation-info>\n` +
`            <citation-type code="ar"/>\n` +
`            <citation-language xml:lang="ENG"/>\n` +
`            <abstract-language xml:lang="ENG"/>\n` +
`${kwXml}` +
`          </citation-info>\n` +
`          <citation-title>\n` +
`            <titletext xml:lang="ENG" original="y">${escapeXml(chosenTitle)}</titletext>\n` +
`          </citation-title>\n` +
`${authorsXml}` +
`${absXml}` +
`          <source srcid="???"/>\n` +
`        </head>\n` +
`${bibXml}` +
`      </bibrecord>\n` +
`    </unit-content>\n` +
`  </unit>\n` +
`</units>\n`;
  }

  // ----------------------------
  // Support-doc detection by content (API vs scrape vs FINAL)
  // ----------------------------
  async function detectSupportDocsByContent(zip, guessedId) {
    const names = Object.keys(zip.files).filter(n => !zip.files[n].dir);

    const xmlNames = names.filter(n => lower(n).endsWith(".xml"));
    const htmlNames = names.filter(n => lower(n).endsWith(".html") || lower(n).endsWith(".htm"));

    let apiName = null;
    let scrapeName = null;
    let finalName = null;

    for (const n of xmlNames) {
      const txt = await zip.file(n).async("string");
      const head = txt.slice(0, 9000).toLowerCase();

      const looksFinal = head.includes("<units") && head.includes("elsevier.com/xml/ani/ani");
      const looksApi = head.includes("<record") || head.includes("oai:arxiv.org:") || head.includes("<arxiv");
      const looksScrape = head.includes("<item") && head.includes("version") && head.includes("[v");

      if (!finalName && looksFinal) finalName = n;
      else {
        if (!apiName && looksApi) apiName = n;
        if (!scrapeName && looksScrape) scrapeName = n;
      }
    }

    // prefer id-based filenames when available
    if (guessedId) {
      const finalByName = xmlNames.find(n => n.includes(guessedId) && n !== apiName && n !== scrapeName);
      if (finalByName) {
        const txt = await zip.file(finalByName).async("string");
        if (txt.toLowerCase().includes("elsevier.com/xml/ani/ani")) finalName = finalByName;
      }
      const apiByName = xmlNames.find(n => n.includes(guessedId) && n !== finalName && n !== scrapeName);
      if (apiByName) apiName = apiByName;

      const scrapeByName = xmlNames.find(n => n.includes(guessedId) && n !== finalName && n !== apiName);
      if (scrapeByName && !scrapeName) scrapeName = scrapeByName;
    }

    const htmlName = (guessedId
      ? (htmlNames.find(n => n.includes(guessedId)) || htmlNames[0] || null)
      : (htmlNames[0] || null)
    );

    return { apiName, scrapeName, htmlName, finalName };
  }

  // ----------------------------
  // ZIP Load
  // ----------------------------
  zipInput.addEventListener("change", async (e) => {
    const file = e.target.files?.[0];
    if (!file) return;

    resetAll();
    zipBadge.className = "badge warn";
    zipBadge.textContent = "Loading ZIP…";

    try {
      const buf = await file.arrayBuffer();
      const zip = await JSZip.loadAsync(buf);
      state.zip = zip;

      state.fileNames = Object.keys(zip.files).filter(n => !zip.files[n].dir);
      state.pdfs = state.fileNames.filter(n => lower(n).endsWith(".pdf"));

      fileCount.textContent = String(state.pdfs.length);
      zipBadge.className = "badge good";
      zipBadge.textContent = `ZIP loaded: ${file.name}`;

      renderPdfList();
      if (state.pdfs.length) selectPdf(0);

    } catch (err) {
      console.error(err);
      zipBadge.className = "badge bad";
      zipBadge.textContent = "Failed to read ZIP";
    }
  });

  function resetAll(){
    state.fileNames = [];
    state.pdfs = [];
    state.selectedPdf = null;
    state.selected = { pdfName:null, apiName:null, scrapeName:null, htmlName:null, finalName:null };

    apiText.value = "";
    scrapeText.value = "";
    finalText.value = "";
    htmlPreview.innerHTML = "No HTML loaded.";
    outXml.value = "";

    downloadBtn.disabled = true;
    runBtn.disabled = true;

    arxivIdVal.textContent = "—";
    versionVal.textContent = "—";
    matchVal.innerHTML = "—";
    titleVal.textContent = "—";
    absVal.innerHTML = "—";
    kwVal.innerHTML = "—";
    authVal.innerHTML = "—";
    refVal.innerHTML = "—";
    orcidVal.innerHTML = "—";

    selectedSet.textContent = "No set selected";

    clearPdf();
    fileList.innerHTML = "";
    fileCount.textContent = "0";
  }

  // ----------------------------
  // Render PDF list
  // ----------------------------
  function renderPdfList(){
    fileList.innerHTML = "";
    state.pdfs.forEach((pdfName, idx) => {
      const div = document.createElement("div");
      div.className = "item" + (idx === state.selectedPdf ? " active" : "");
      const idGuess = extractArxivFromText(pdfName).id || "PDF";
      div.innerHTML = `
        <div style="display:flex;align-items:center;justify-content:space-between;gap:8px">
          <div style="font-weight:900;font-size:13px">${escapeHtml(pdfName.split("/").pop())}</div>
          <span class="badge">${escapeHtml(idGuess)}</span>
        </div>
        <div class="muted" style="margin-top:6px">Auto-detects API/Scrape/HTML/Final XML by file content.</div>
      `;
      div.addEventListener("click", () => selectPdf(idx));
      fileList.appendChild(div);
    });
  }

  async function selectPdf(idx){
    state.selectedPdf = idx;
    renderPdfList();

    const pdfName = state.pdfs[idx];
    selectedSet.textContent = `Selected: ${pdfName.split("/").pop()}`;

    const { id: guessedId } = extractArxivFromText(pdfName);
    const support = await detectSupportDocsByContent(state.zip, guessedId);

    state.selected = {
      pdfName,
      apiName: support.apiName,
      scrapeName: support.scrapeName,
      htmlName: support.htmlName,
      finalName: support.finalName
    };

    runBtn.disabled = false;

    await loadPdfFromZip(pdfName);
    await loadTextPreview(state.selected.apiName, apiText);
    await loadTextPreview(state.selected.scrapeName, scrapeText);
    await loadTextPreview(state.selected.finalName, finalText);
    await loadHtmlPreview(state.selected.htmlName);

    // If final XML exists in ZIP, show it in output too (so user sees something instantly)
    if (finalText.value && finalText.value.trim().startsWith("<?xml")) {
      outXml.value = finalText.value;
      downloadBtn.disabled = false;
    }
  }

  async function loadTextPreview(name, targetTextarea){
    if (!name) { targetTextarea.value = ""; return; }
    const file = state.zip.file(name);
    if (!file) { targetTextarea.value = ""; return; }
    targetTextarea.value = await file.async("string");
  }

  async function loadHtmlPreview(name){
    if (!name) { htmlPreview.innerHTML = "No HTML loaded."; return; }
    const file = state.zip.file(name);
    if (!file) { htmlPreview.innerHTML = "No HTML loaded."; return; }
    const txt = await file.async("string");
    htmlPreview.innerHTML = stripScripts(txt) || "No HTML content.";
  }

  // ----------------------------
  // PDF preview
  // ----------------------------
  function clearPdf(){
    state.pdfDoc = null;
    state.pdfPageNum = 1;
    state.pdfPageCount = 0;
    pageInfo.textContent = "- / -";
    prevPageBtn.disabled = true;
    nextPageBtn.disabled = true;
    const ctx = pdfCanvas.getContext("2d");
    ctx.clearRect(0,0,pdfCanvas.width,pdfCanvas.height);
  }

  async function loadPdfFromZip(name){
    clearPdf();
    const file = state.zip.file(name);
    if (!file) return;

    const u8 = await file.async("uint8array");
    const loadingTask = pdfjsLib.getDocument({ data: u8 });
    const pdf = await loadingTask.promise;

    state.pdfDoc = pdf;
    state.pdfPageCount = pdf.numPages;
    state.pdfPageNum = 1;

    await renderPdfPage(1);
  }

  async function renderPdfPage(num){
    if (!state.pdfDoc) return;
    const page = await state.pdfDoc.getPage(num);
    const viewport = page.getViewport({ scale: 1.3 });
    const ctx = pdfCanvas.getContext("2d");
    pdfCanvas.width = viewport.width;
    pdfCanvas.height = viewport.height;

    await page.render({ canvasContext: ctx, viewport }).promise;

    pageInfo.textContent = `${num} / ${state.pdfPageCount}`;
    prevPageBtn.disabled = (num <= 1);
    nextPageBtn.disabled = (num >= state.pdfPageCount);
  }

  prevPageBtn.addEventListener("click", async () => {
    if (!state.pdfDoc || state.pdfPageNum <= 1) return;
    state.pdfPageNum -= 1;
    await renderPdfPage(state.pdfPageNum);
  });

  nextPageBtn.addEventListener("click", async () => {
    if (!state.pdfDoc || state.pdfPageNum >= state.pdfPageCount) return;
    state.pdfPageNum += 1;
    await renderPdfPage(state.pdfPageNum);
  });

  // ----------------------------
  // STRICT matching rule (your rule)
  // - ID must match across PDF+API+Scrape+HTML (when present)
  // - Version rule:
  //    * If PDF has version => all must match that version (HTML+Scrape at minimum)
  //    * If PDF has no version => HTML version must equal Scrape version
  // ----------------------------
  function computeMatch({ pdfId, pdfVer, apiId, htmlId, htmlVer, scrapeId, scrapeVer }) {
    const ids = [pdfId, apiId, htmlId, scrapeId].filter(Boolean);
    const idOk = ids.length >= 3 && ids.every(x => x === ids[0]); // require real agreement

    let verOk = false;
    let finalVer = "";

    if (pdfVer) {
      // strict: require html+scrape present and equal to pdfVer
      verOk = (!!htmlVer && !!scrapeVer && htmlVer === pdfVer && scrapeVer === pdfVer);
      finalVer = pdfVer;
    } else {
      // strict: require html+scrape both present and equal
      verOk = (!!htmlVer && !!scrapeVer && htmlVer === scrapeVer);
      finalVer = htmlVer || scrapeVer || "";
    }

    const finalId = ids[0] || "";
    return { matchOk: idOk && verOk, finalId, finalVer, idOk, verOk };
  }

  // ----------------------------
  // Run Extraction
  // ----------------------------
  runBtn.addEventListener("click", async () => {
    try {
      if (!state.selected?.pdfName) return;

      // Parse support docs
      const apiRaw = apiText.value || "";
      const scrapeRaw = scrapeText.value || "";
      const htmlRaw = state.selected.htmlName ? await state.zip.file(state.selected.htmlName).async("string") : "";

      const api = apiRaw ? parseApiXml(apiRaw) : null;
      const scrape = scrapeRaw ? parseScrapeXml(scrapeRaw) : null;
      const html = htmlRaw ? parseHtmlLanding(htmlRaw) : null;

      // PDF-based extractions
      const pdfFirstText = await extractPdfTextFirstPages(2);
      const pdfAllText = await extractPdfTextAllPagesCap(40);

      const pdfAr = extractArxivFromText(pdfFirstText) || {};
      const fileGuess = extractArxivFromText(state.selected.pdfName) || {};
      const pdfId = (pdfAr.id || fileGuess.id || "").trim();
      const pdfVer = (pdfAr.version || fileGuess.version || "").trim();

      const apiId = (api?.id || "").trim();
      const htmlId = (html?.id || "").trim();
      const scrapeId = (scrape?.id || "").trim();

      const htmlVer = (html?.version || "").trim();
      const scrapeVer = (scrape?.version || "").trim();

      const { matchOk, finalId, finalVer } = computeMatch({ pdfId, pdfVer, apiId, htmlId, htmlVer, scrapeId, scrapeVer });

      // Title/abstract: keep your preference (HTML title if present else API title)
      const chosenTitle = (html?.title || api?.title || "").trim();
      const absText = (api?.abstract || html?.abstract || "").trim();

      // Keywords: STRICT (no fake)
      const keywords = parseKeywordsStrict(pdfFirstText, html);

      // Authors from API (reliable names)
      const apiAuthors = api?.authors || [];

      // Affiliation + emails/orcid from PDF (best-effort)
      const affiliations = parseAffiliationsFromPdfFirstPage(pdfFirstText);
      const emails = uniq((pdfFirstText.match(EMAIL_RE) || []).map(s=>s.trim()));
      const orcids = uniq((pdfFirstText.match(ORCID_RE) || []).map(s=>s.trim()));

      // References from PDF (best-effort)
      const references = parseReferencesFromPdf(pdfAllText);

      // Build authorGroups
      // If we found any affiliation lines, we put ALL authors under one group with that affiliation (strict structure).
      // If multiple lines, we keep them as multiple <organization> tags.
      const affObj = affiliations.length ? {
        confidence: 0.55,
        organizations: affiliations.slice(0, 5),
        sourceText: affiliations.join(" ")
      } : null;

      const authorGroups = [];
      if (apiAuthors.length) {
        const authorsWithExtras = apiAuthors.map((a, i) => ({
          ...a,
          seq: i+1,
          email: (i===0 ? (emails[0] || "") : ""), // best-effort: attach first email to first author
          orcid: (i===0 ? (orcids[0] || "") : "")
        }));

        authorGroups.push({
          seq: 1,
          authors: authorsWithExtras,
          affiliation: affObj
        });
      }

      // UI
      const arxivIdWithVersion = (finalId && finalVer) ? `${finalId}${finalVer}` : (finalId || "");

      arxivIdVal.textContent = finalId || "—";
      versionVal.textContent = finalVer || "—";
      matchVal.innerHTML = matchOk ? badge("OK – IDs & versions match", "good") : badge("HOLD – Version/ID mismatch", "bad");
      titleVal.textContent = chosenTitle || "—";
      absVal.innerHTML = absText ? badge("Yes", "good") : badge("No", "warn");
      kwVal.innerHTML = keywords.length ? badge(`${keywords.length} keyword(s)`, "good") : badge("None (strict)", "warn");
      authVal.innerHTML = apiAuthors.length
        ? badge(`Authors: ${apiAuthors.length} (affils from PDF: ${affiliations.length ? "yes" : "no"})`, affiliations.length ? "good" : "warn")
        : badge("No authors parsed", "bad");
      refVal.innerHTML = references.length ? badge(`${references.length} reference(s)`, "good") : badge("0 (not found)", "warn");
      orcidVal.innerHTML = orcids.length ? badge(`${orcids.length} found`, "good") : badge("None", "warn");

      // IMPORTANT: If mismatch => still generate XML but user sees HOLD (you can also blank it if you want)
      const xml = buildElsevierXmlStrict({
        arxivIdWithVersion,
        chosenTitle: chosenTitle || "—",
        abstractText: absText,
        keywords,
        authorGroups: authorGroups.length ? authorGroups : [{
          seq: 1,
          authors: [{ seq: 1, forenames: "", keyname: "" }],
          affiliation: affObj
        }],
        references
      });

      outXml.value = xml;
      downloadBtn.disabled = !xml;

    } catch (e) {
      console.error(e);
      alert("Extraction failed. Open DevTools Console and send me the red error line.");
    }
  });

  downloadBtn.addEventListener("click", () => {
    const xml = outXml.value;
    if (!xml) return;
    const blob = new Blob([xml], { type: "application/xml;charset=utf-8" });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = `ACE_${Date.now()}_arxiv.xml`;
    document.body.appendChild(a);
    a.click();
    a.remove();
  });
</script>
</body>
</html>
